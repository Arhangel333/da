#include "constructors.cpp"
//const int CONSTRUCTORS = 0, TREE_CONSTRUCTORS = 0, PASTING_BALANCING = 1, SHOW_TREE_IN_BALANCE = 1, DELETING_BALANCE = 1;
template <typename T>
struct Node
{
    Node *l = 0;
    Node *r = 0;
    Node *p = 0;
    T data;
    T *ptr = &data;
    char color = 'b';

    Node()
    {
        //T *p = &this->data;
        this->ptr = new T;
        if (CONSTRUCTORS)
        {

            printf("EmptyConstructed node (%d)\n", this->data);
        }
    }
    Node(Node &n)
    {
        //T *p = &this->data;
        this->ptr = new T;
        this->data = n.data;
        this->l = n.l;
        this->r = n.r;
        this->p = n.p;
        this->color = n.color;
        if (CONSTRUCTORS)
        {
            printf("CopyConstructed node (%d)\n", this->data);
        }
    }
    Node(T t)
    {
        //T *p = &this->data;
        this->ptr = new T;
        this->data = t;
        if (CONSTRUCTORS)
        {
            printf("Constructed node (%d)\n", this->data);
        }
    }

    ~Node()
    {
        if (CONSTRUCTORS)
        {
            cout << p;
            printf("Deleted node (%d)\n", this->data);
        }
        delete this->ptr;
        if (CONSTRUCTORS)
        {
            printf("EndDel node (%d)\n", this->data);
        }
    }
};

template <typename T>
struct Tree
{

    Node<T> *root = 0;
    Node<T> *now = this->root;
    int size = 0;
    int levels = 0;

    Tree()
    {
        if (TREE_CONSTRUCTORS)
        {
            printf("Constructed tree (%d)\n", this->size);
        }
    }
    Tree(Tree &tr)
    {
        this->root = tr.root;
        this->size = tr.size;
        this->now = tr.now;
    }

    void GoL()
    {
        this->now = this->now->l;
    }

    void GoR()
    {
        this->now = this->now->r;
    }

    void GoP()
    {
        this->now = this->now->p;
    }

    void PushTree(Node<T> &n)
    {
        if (this->root == 0)
        {

            this->root = &n;
            this->now = this->root;
            this->now->l = 0;
            this->now->r = 0;
            this->now->p = 0;
            this->size++;
            printf("root pushed, size == %d\n", this->size);
        }
        else
        {
            printf("pushing node %d \n", n.data);
            this->now = this->root;
            this->Paste(n, this->root->p);
#ifdef PASTING_BALANCING
            this->ShowTree(this->root);
#endif
            this->Balance(this->now);
        }
    }

    void TLevel()
    {
        this->levels = 0;
        if (this->root != 0)
        {
            this->TreeLevel(this->root, 1);
        }
    }

    Node<T> *FindNode(T x, Node<T> *n)
    {
        if (n->data == x)
        {
            cout << "нашёл" << x << endl;
            return n;
        }
        else
        {
            if ((n->l != 0) && (n->data >= x))
            {
                cout << "ищу слева" << x << n->data << endl;
                this->FindNode(x, n->l);
            }
            else
            {
                if ((n->r != 0) && (n->data < x))
                {
                    cout << "ищу справа" << x << n->data << endl;
                    this->FindNode(x, n->r);
                }
                else
                {
                    return 0;
                }
            }
        }
    }

    void PrevNull(Node<T> *n)
    {
        if (n->p != 0)
        {
            if ((n->l != 0) || (n->r != 0))
            {
                if (n->l != 0)
                {
                    if (n->p->r == n) //у предыдущего зануляем
                    {
                        n->p->r = n->l;
                    }
                    else
                    {
                        n->p->l = n->l;
                    }
                    n->l->p = n->p;
                }
                else
                {
                    if (n->p->r == n) //у предыдущего зануляем
                    {
                        n->p->r = n->r;
                    }
                    else
                    {
                        n->p->l = n->r;
                    }
                    n->r->p = n->p;
                }
            }
            else
            {
                if (n->p->r == n) //у предыдущего зануляем
                {
                    n->p->r = 0;
                }
                else
                {
                    n->p->l = 0;
                }
                n->p = 0; //на предыдущий зануляем
            }
        }
        else
        {
#ifdef DELETING_BALANCE
            printf("Корень удаляем значит\n");
#endif
        }
    }

    Node<T> *LeftFall(Node<T> *n)
    { //проваливаемся в левое поддерево
        n = n->l;
        while (n->r != 0)
        {
            n = n->r;
        }
        return n;
    }
    Node<T> *RightFall(Node<T> *n)
    { //проваливаемся в правое поддерево
        n = n->r;
        while (n->l != 0)
        {
            n = n->l;
        }
        return n;
    }

    void RedBlack2(Node<T> *n, Node<T> *del)
    {
        if (n->l != 0)
        {
            n = this->LeftFall(n);
        }
        else
        {
            n = this->RightFall(n);
        }
        del->data = n->data;
        this->DelBalance(n, n);
    }

    void RightRot(Node<T> *dad, Node<T> *son)
    { //son слева от dad

        if (this->root == dad)
        {
#ifdef PASTING_BALANCING
            printf("Дед(%d) - корень(R)\n", dad->data);
#endif
            this->root = son; //если отец - корень
            son->p = dad->p;

            dad->p = son;
            dad->l = son->r;
            if (son->r != 0)
            {
                son->r->p = dad;
            }
            son->r = dad;
        }
        else
        {
            if (dad->p->l == dad)
            {
#ifdef PASTING_BALANCING
                printf("Дед%d - левый(R)\n", dad->data);
#endif
                dad->p->l = son;
            }
            else
            {
#ifdef PASTING_BALANCING
                printf("Дед%d - правый(R)\n", dad->data);
#endif
                dad->p->r = son;
            }
            son->p = dad->p;
            dad->p = son;
            dad->l = son->r;
            if (son->r != 0)
            {
                son->r->p = dad;
            }
            son->r = dad;
#ifdef PASTING_BALANCING
            this->PrintTree();
#endif
        }
    }

    void LeftRot(Node<T> *dad, Node<T> *son)
    { //son справа от dad
        if (this->root == dad)
        {
#ifdef PASTING_BALANCING
            printf("Дед(%d) - корень(L)\n", dad->data);
            cout << (son->data) << endl;
#endif
            this->root = son; //если отец - корень
            son->p = dad->p;

            dad->p = son;
            dad->r = son->l;
            if (son->l != 0)
            {
                son->l->p = dad;
            }
            son->l = dad;
        }
        else
        {
            if (dad->p->l == dad)
            {
#ifdef PASTING_BALANCING
                printf("Дед%d - левый(L)\n", dad->data);
#endif
                dad->p->l = son;
            }
            else
            {
#ifdef PASTING_BALANCING
                printf("Дед%d - правый(L)\n", dad->data);
#endif
                dad->p->r = son;
            }
            son->p = dad->p;
            dad->p = son;
            dad->r = son->l;
            if (son->l != 0)
            {
                son->l->p = dad;
            }
            son->l = dad;
#ifdef PASTING_BALANCING
            this->PrintTree();
#endif
        }
    }

    void Black1(Node<T> *n, Node<T> *del)
    {
        if (n->l != 0)
        {
            n = n->l;
        }
        else
        {
            n = n->r;
        }
        del->data = n->data;
        this->PrevNull(n);
    }

    void Red0(Node<T> *n, Node<T> *del)
    {
        this->PrevNull(n);
    }

    void RB1(Node<T> *dad, Node<T> *son, Node<T> *vnuk)
    {
        dad->color = 'b';
        son->color = 'r';
    }

    void RB2(Node<T> *dad, Node<T> *son, Node<T> *vnuk)
    {
        dad->color = 'b';
        son->color = 'r';
        this->RightRot(dad, son);
    }

    void BR3(Node<T> *dad, Node<T> *son)
    {
        son->r->color = 'r';
        son->color = 'b';
        this->RightRot(dad, son);
    }

    void BR4(Node<T> *dad, Node<T> *son)
    {
        son->r->l->color = 'b';
        this->LeftRot(son, son->r);
        this->RightRot(dad, son->p);
    }

    void BB5(Node<T> *dad, Node<T> *son)
    {
        son->r->color = 'b';
        this->LeftRot(son, son->r);
        this->RightRot(dad, son->p);
    }

    void BB6(Node<T> *dad, Node<T> *son)
    {
        son->color = 'r';
        this->DelBalance(dad->p, dad->p);
    }

    void RightRB1(Node<T> *dad, Node<T> *son, Node<T> *vnuk)
    {
        dad->color = 'b';
        son->color = 'r';
    }

    void RightRB2(Node<T> *dad, Node<T> *son, Node<T> *vnuk)
    {
        dad->color = 'b';
        son->color = 'r';
        this->LeftRot(dad, son);
    }

    void RightBR3(Node<T> *dad, Node<T> *son)
    {
        son->l->color = 'r';
        son->color = 'b';
        this->LeftRot(dad, son);
    }

    void RightBR4(Node<T> *dad, Node<T> *son)
    {
        son->l->r->color = 'b';
        this->RightRot(son, son->l);
        this->LeftRot(dad, son->p);
    }

    void RightBB5(Node<T> *dad, Node<T> *son)
    {
        son->l->color = 'b';
        this->RightRot(son, son->l);
        this->LeftRot(dad, son->p);
    }

    void RightBB6(Node<T> *dad, Node<T> *son)
    {
        son->color = 'r';
        this->DelBalance(dad->p, dad->p);
    }

    void Black0(Node<T> *n)
    {
        if (n->p->l == n)
        {
            this->Black0Left(n);
        }
        else
        {
            this->Black0Right(n);
        }
    }

    void Black0Left(Node<T> *n)
    {
        #ifdef DELETING_BALANCE
        printf("Левый случай\n");
#endif
        Node<T> *dad = n->p, *son, *vnuk;
        Node<T> *min = this->RightFall(dad);
        if (min->color == 'r')
        {
            #ifdef DELETING_BALANCE
            printf("min\n");
#endif
            n->data = dad->data;
            dad->data = min->data;
            this->PrevNull(min);
            return;
        }
        if (dad->color == 'r')
        {
#ifdef DELETING_BALANCE
            printf("Отец - красный\n");
#endif
            if (dad->r->r != 0)
            {
                n->data = dad->data;
                dad->data = dad->r->data;
                dad->r->data = dad->r->r->data;
                this->PrevNull(dad->r->r);
            }
            else
            {
                this->PrevNull(n);
                dad->color = 'b';
                dad->r->color = 'r';
            }
        }
        else
        {
#ifdef DELETING_BALANCE
            printf("Отец - чёрный\n");
#endif
            this->B0LBlackdad(n, dad);
        }
    }

    void B0LBlackdad(Node<T> *n, Node<T> *dad)
    { //чёрный отец для левого случая
        Node<T> *son = dad->r;
        if (dad->r->color == 'b')
        {
            if (dad->r->r != 0)
            {
                n->data = dad->data;
                dad->data = dad->r->data;
                dad->r->data = dad->r->r->data;
                this->PrevNull(dad->r->r);
            }
            else
            {
                //Hurdest case left
            }
        }
        else
        {
            Node<T> *ud;
            if ((son->l->l != 0) || (son->l->r != 0))
            {
                #ifdef DELETING_BALANCE
                printf("У правого сына есть внуки\n");
#endif
                if (son->l->l != 0)
                {
#ifdef DELETING_BALANCE
                    printf("Используем правого правнука\n");
#endif
                    ud = son->l->l;
                }
                else
                {
#ifdef DELETING_BALANCE
                    printf("Используем левого правнука\n");
#endif
                    ud = son->l->r;
                }
                n->data = dad->data;
                dad->data = son->l->data;
                son->l->data = ud->data;
                this->PrevNull(ud);
return;




            }
            if ((son->r->l != 0) || (son->r->r != 0))
            {
                if (son->r->l != 0)
                {
                    ud = son->r->l;
                }
                else
                {
                    ud = son->r->r;
                }
                n->data = dad->data;
                dad->data = son->l->data;
                son->l->data = son->data;
                son->data = ud->data;
                this->PrevNull(ud); //гарантировано красный ud
            }
            else
            {
                son->color = 'b';
                son->l->color = 'r';
                son->r->color = 'r';
                this->Black0(n);
            }
        }
    }

    void Black0Right(Node<T> *n)
    {
#ifdef DELETING_BALANCE
        printf("Правый случай\n");
#endif
        Node<T> *dad = n->p, *son, *vnuk;
        Node<T> *min = this->LeftFall(dad);
        if (min->color == 'r')
        {
#ifdef DELETING_BALANCE
            printf("min\n");
#endif
            n->data = dad->data;
            dad->data = min->data;
            this->PrevNull(min);
            return;
        }
        if (dad->color == 'r')
        {
#ifdef DELETING_BALANCE
            printf("Отец - красный\n");
#endif
            if (dad->l->l != 0)
            {
#ifdef DELETING_BALANCE
                printf("Внуки у другого сына есть\n");
#endif
                n->data = dad->data;
                dad->data = dad->l->data;
                dad->l->data = dad->l->l->data;
                this->PrevNull(dad->l->l);
            }
            else
            {
#ifdef DELETING_BALANCE
                printf("Внуков у другого сына нет\n");
#endif
                this->PrevNull(n);
                dad->color = 'b';
                dad->l->color = 'r';
            }
        }
        else
        {
#ifdef DELETING_BALANCE
            printf("Отец - чёрный\n");
#endif
            this->B0RBlackdad(n, dad);
        }
    }

    void B0RBlackdad(Node<T> *n, Node<T> *dad)
    {
        Node<T> *son = dad->l;
        if (dad->l->color == 'b')
        {
#ifdef DELETING_BALANCE
            printf("Левый сын - чёрный\n");
#endif
            if (dad->l->l != 0)
            {
                n->data = dad->data;
                dad->data = dad->l->data;
                dad->l->data = dad->l->l->data;
                this->PrevNull(dad->l->l);
            }
            else
            {
                //Hurdest case right
            }
        }
        else
        {
#ifdef DELETING_BALANCE
            printf("Левый сын - красный\n");
#endif
                Node<T> *ud;
            if ((son->r->r != 0) || (son->r->l != 0))
            {
                #ifdef DELETING_BALANCE
                printf("У правого сына есть внуки\n");
#endif
                if (son->r->r != 0)
                {
#ifdef DELETING_BALANCE
                    printf("Используем правого правнука\n");
#endif
                    ud = son->r->r;
                }
                else
                {
#ifdef DELETING_BALANCE
                    printf("Используем левого правнука\n");
#endif
                    ud = son->r->l;
                }
                n->data = dad->data;
                dad->data = son->r->data;
                son->r->data = ud->data;
                this->PrevNull(ud);
return;




            }
            if ((son->l->r != 0) || (son->l->l != 0))
            {
#ifdef DELETING_BALANCE
                printf("У левого сына есть внуки\n");
#endif

                if (son->l->r != 0)
                {
#ifdef DELETING_BALANCE
                    printf("Используем правого правнука\n");
#endif
                    ud = son->l->r;
                }
                else
                {
#ifdef DELETING_BALANCE
                    printf("Используем левого правнука\n");
#endif
                    ud = son->l->l;
                }
                n->data = dad->data;
                dad->data = son->r->data;
                son->r->data = son->data;
                son->data = ud->data;
                this->PrevNull(ud); //гарантировано красный ud
            }
            else
            {
#ifdef DELETING_BALANCE
                printf("У сына нет внуков\n");
#endif
                son->color = 'b';
                son->r->color = 'r';
                son->l->color = 'r';
                this->Black0(n);
            }
        }
    }

    /*     void Black0(Node<T> *n, Node<T> *del)
    {
        Node<T> *dad = n->p, *son, *vnuk;
        this->PrevNull(n);

        if (dad->r == n)
        { //левый случай
        #ifdef DELETING_BALANCE
        printf("Левый случай\n");
        #endif
            son = dad->l;
            

            if (dad->color == 'r')
            {                           //родитель красный
            #ifdef DELETING_BALANCE
        printf("родитель красный\n");
        #endif
                if(son->l != 0){
                vnuk = son->l;
                if (vnuk->color == 'r') //р- кр, с- ч, лвнук- кр.
                {
                    this->RB2(dad, son, vnuk);
                }
                else //р- кр, с- ч, лвнук- ч.
                {
                    this->RB1(dad, son, vnuk);
                }
                }else{
                    
                }

                ////////////////////////////////////black
            }
            else
            { //родитель чёрный
            #ifdef DELETING_BALANCE
        printf("родитель чёрный\n");
        #endif
                if (son->color == 'r')
                {                                                               //сын - кр
                    if ((son->r->l->color == 'b') && (son->r->r->color == 'b')) //у правого внука левый правнук - красный
                    {
                        this->BR3(dad, son);
                    }
                    else
                    {
                        this->BR4(dad, son);
                    }
                }
                else
                {                             //сын - ч
                    if (son->r->color == 'r') //родитель - ч, лсын - ч, внуки - кр и ...
                    {
                        this->BB5(dad, son);
                    }
                    else //родитель - ч, лсын - ч, внуки - ч
                    {
                        this->BB6(dad, son);
                    }
                }
            }
        }
        else
        { //правый случай
        #ifdef DELETING_BALANCE
        printf("Правый случай\n");
        #endif
            son = dad->r;
            if(son->r != 0)
            vnuk = son->r;

            if (dad->color == 'r')
            {                           //родитель красный
            #ifdef DELETING_BALANCE
        printf("родитель красный\n");
        #endif
                if (vnuk->color == 'r') //р- кр, с- ч, лвнук- кр.
                {
                    this->RightRB2(dad, son, vnuk);
                }
                else //р- кр, с- ч, лвнук- ч.
                {
                    this->RightRB1(dad, son, vnuk);
                }

                ////////////////////////////////////black
            }
            else
            { //родитель чёрный
            #ifdef DELETING_BALANCE
        printf("родитель чёрный\n");
        #endif
                if (son->color == 'r')
                {                                                               //сын - кр
                    if ((son->l->l->color == 'b') && (son->l->r->color == 'b')) //у правого внука правый правнук - красный
                    {
                        this->RightBR3(dad, son);
                    }
                    else
                    {
                        this->RightBR4(dad, son);
                    }
                }
                else
                {                             //сын - ч
                    if (son->l->color == 'r') //родитель - ч, п сын - ч, внуки - кр и ...
                    {
                        this->RightBB5(dad, son);
                    }
                    else //родитель - ч, п сын - ч, внуки - ч
                    {
                        this->RightBB6(dad, son);
                    }
                }
            }
        }
    } */

    void DelBalance(Node<T> *n, Node<T> *del)
    {
        if ((n->l != 0) && (n->r != 0))
        { //если 2 сына    //К2 или Ч2
            this->RedBlack2(n, del);
        }
        else
        {
            if ((n->l != 0) || (n->r != 0))
            { //если 1 сын  (Ч1)
                this->Black1(n, del);
            }
            else
            { //если 0 сыновей
                if (n->color == 'r')
                { //К0
                    this->Red0(n, del);
                }
                else
                { //Ч0
                    del->data = n->data;
                    this->Black0(n);
                }
            }
        }
    }

    Node<T> PopTree(Node<T> *n) //типо удoляем del, но по факту удоляем n
    {
        Node<T> res = *n;
        Node<T> *del = n; //запоминаем указатель удоляемого элемента
        this->DelBalance(n, del);
        return res;

        /* 
            if (n->l != 0)
            {                                   //если ходим налево
                n = n->l;
                while (n->r != 0)
                {
                    n = n->r;
                }

                del->data = n->data; //меняем наш элемент с самым правым из левого поддерева

                this->DelInSub(n);   // (K2) (Ч1) (Ч2)
            }
            else                        //если надо идти в на Право
            {
                if (n->r != 0)
                { //если слева никого, а справа есть кто-то
                    while (n->l != 0)
                    {
                        n = n->l;
                    }

                    del->data = n->data; //меняем наш элемент с самым левым из правого поддерева
                    this->DelInSub(n); // (K2) (Ч1) (Ч2)
                }
                else
                { //если детей нет
                                                //если убиваем вдовца
                        if (n->color == 'r')
                        {                                   //красный вдовец (К0)
                        #ifdef DELETING_BALANCE
                        printf("убили красного вдовца\n");
                        #endif
                        this->PrevNull(n);
                        }
                        else
                        {                                   //чёрный вдовец  (Ч0)
                        #ifdef DELETING_BALANCE
                        printf("убили чёрного вдовца\n");
                        #endif
                        }
                }
            } */
    }

    void DestroySubTree() {}

    void ShowTree(Node<T> *n, int count = 0)
    {
        for (int i = 0; i < count; i++)
        {
            printf("|");
        }
        if (n->p != 0)
        {
            if (n->p->l == n)
            {
                cout << "(l)";
            }
            else
            {
                cout << "(r)";
            }
        }
        printf("[%d]", count);
        cout << n->data << n->color << endl;
        count++;
        if (n->l != 0)
        {
            this->ShowTree(n->l, count);
        }
        if (n->r != 0)
        {
            this->ShowTree(n->r, count);
        }
    }

    void PrintTree()
    {
        if (this->size == 0)
        {
            printf("Tree is empty\n");
            return;
        }
        this->TLevel();
        int p = 1, levelcount = this->levels;
        Node<T> *arr[p];
        arr[0] = this->root;
        int y = Step(2, levelcount - 1);
        for (int i = 0; i < y; i++)
        {
            printf(" ");
        }
        cout << this->root->data << this->root->color << endl;
        this->Printic(arr, p * 2, levelcount);
    }

    ~Tree()
    {
        if (TREE_CONSTRUCTORS)
        {
            printf("Destructed tree (%d)\n", this->size);
        }
    }

private:
    void TreeLevel(Node<T> *node, int l)
    {
        if (node->l != 0)
        {
            this->TreeLevel(node->l, l + 1);
        }
        if (node->r != 0)
        {
            this->TreeLevel(node->r, l + 1);
        }
        if ((node->r == 0) && (node->l == 0) && (this->levels < l))
        {
            this->levels = l;
        }
    }

    void Printic(Node<T> **arr, int p, int levelcount)
    {
        /* for (int i = 0; i < p/2; i++)
        {
            if(arr[i] != 0){
                printf("%d ", arr[i]->data);
            }else{
                printf("0 ");
            }
            
        }*/

        if (levelcount == 0)
        {
            return;
        }
        Node<T> *arrc[p]; //p уже домножено на 2 и == потенц. кол-ву детей

        for (int i = 0; i < p; i++)
        {
            arrc[i] = 0;
        }

        int empty = 0;

        for (int i = 0; i < p / 2; i++)
        {
            if (arr[i] != 0)
            {

                if (arr[i]->l != 0)
                {
                    empty++;
                    //printf("hello1[%d]\n",i);
                    arrc[i * 2] = arr[i]->l;
                    //printf("hello1[%d]\n",arrc[i * 2]->data);
                }
                else
                {
                    //printf("hello12[%d]\n",i);
                    arrc[i * 2] = 0;
                }
                if (arr[i]->r != 0)
                {
                    empty++;
                    //printf("hello21[%d]\n",i);
                    arrc[i * 2 + 1] = arr[i]->r;
                    //printf("hello1[%d]\n",arrc[i * 2 + 1]->data);
                }
                else
                {
                    //printf("hello22[%d]\n",i);
                    arrc[i * 2 + 1] = 0;
                }
            }
            else
            {
                arrc[i * 2] = 0;
                arrc[i * 2 + 1] = 0;
            }
        }

        if (empty == 0)
        {
            return;
        }

        printf("\n");
        for (int i = 0; i < Step(2, levelcount - 1) / 2; i++)
        {
            printf(" "); //пробел
        }

        for (int childs = 0; childs < p; childs++)
        {
            if (arrc[childs] != 0)
            {
                if (childs % 2 != 0)
                {
                    printf("п");
                }
                else
                {
                    printf("л");
                }
                cout << arrc[childs]->data << arrc[childs]->color;
            }
            else
            {
                printf(" "); //пустое место от символа
            }
            for (int i = 0; i < Step(2, levelcount - 1); i++)
            {
                printf(" "); //пробел
            }
        }
        printf("\n");
        this->Printic(arrc, p * 2, levelcount - 1);
    }

    void Paste(Node<T> &n, Node<T> *prev)
    {
        if (this->now == 0)
        {
            this->now = &n;
            n.color = 'r';
            this->now->p = prev;

            if (n.data <= this->now->p->data)
            {
                this->now->p->l = &n;
            }
            else
            {
                this->now->p->r = &n;
            }
            this->now->l = 0;
            this->now->r = 0;
            this->size++;

            printf("%d node pushed after %d\n", this->now->data, this->now->p->data);
        }
        else if (n.data <= this->now->data)
        {
            prev = this->now;
            this->GoL();
            this->Paste(n, prev);
        }
        else if (n.data > this->now->data)
        {
            prev = this->now;
            this->GoR();
            this->Paste(n, prev);
        }
    }

    void Balance(Node<T> *pasted)
    {
        if (pasted == this->root)
        { //Если вызвали для корня, то просто красим его в чёрный
            pasted->color = 'b';
            return;
        }

        if (pasted->p == this->root)
        { //Если нет деда, то выход
#ifdef PASTING_BALANCING
            printf("Для(%d):Мы у корня, так что балансировать нечего\n", pasted->data);
#endif
            return;
        }

        Node<T> *uncle = this->FindUncle(pasted);
#ifdef PASTING_BALANCING
        if (uncle != 0)
        {
            cout << pasted->data << " now uncle " << uncle->data << endl;
            cout << ((pasted->p->color == 'r') && (pasted->color == 'r')) << (uncle != 0) << (uncle->color == 'r') << endl;
        }
        else
        {
            cout << " UNCLE - ZERO " << endl;
        }
#endif
        if ((pasted->p->color == 'r') && (pasted->color == 'r'))
        { //если отец красный
            if (uncle != 0)
            { //если дядя ЕСТЬ
                if (uncle->color == 'r')
                { //если дядя КРАСНЫЙ
                    firstBalance(pasted, uncle);
                }
                else
                { //если дядя ЧЁРНЫЙ
                    secondBalance(pasted, uncle);
                }
            }
            else
            { //если дяди НЕТ
                thirdBalance(pasted);
            }
        }
        else
        {
#ifdef PASTING_BALANCING
            printf("Отец и сын разноцветные, баллансировка не нужна\n");
#endif
        }
#ifdef PASTING_BALANCING
        printf("%d Balanced \n", pasted->data);
        this->PrintTree();
#endif
    }

    void firstBalance(Node<T> *n, Node<T> *uncle)
    {
#ifdef PASTING_BALANCING
        printf("Это вставка ситуация 1\n");
#endif
        if (n->p->p != this->root)
        {
#ifdef PASTING_BALANCING
            printf("Дед - не корень\n");
#endif
            n->p->p->color = 'r';
            n->p->p->l->color = 'b'; //меняем цвета деда и его детей
            n->p->p->r->color = 'b';
            this->Balance(uncle->p); //рекурсия вверх
        }
        else
        {
#ifdef PASTING_BALANCING
            printf("Дед - корень\n");
#endif
            if (n->p->p->l != 0)
                n->p->p->l->color = 'b'; //меняем цвета деда и его детей
            if (n->p->p->r != 0)
                n->p->p->r->color = 'b';
        }
    }

    void secondBalance(Node<T> *n, Node<T> *uncle)
    {
#ifdef PASTING_BALANCING
        printf("Это вставка ситуация 2\n");
#endif
        n = this->OneSide(n, uncle); //с одной ли стороны мы и дядя если нет, то возвращается указатель на отца
        Node<T> *dad = n->p, *grand = dad->p;
        /* if (dad->l == n)
        { //Если вставили в левое поддерево, значит родитель тоже левый
#ifdef PASTING_BALANCING
            printf("Вставляли в левое поддерево\n");
#endif */
#ifdef PASTING_BALANCING
        printf("Вращаем деда\n");
#endif
        if (grand->l == dad)
        {
            this->RightRot(grand, dad);
        }
        else
        {

            this->LeftRot(grand, dad);
        }

        /* }
        else
        { //Если вставили в правое поддерево, значит родитель тоже правый
#ifdef PASTING_BALANCING
            printf("Вставляли в правое дерево\n");
#endif
            if (grand == this->root)
            { //если дед не сын, а корень
#ifdef PASTING_BALANCING
                printf("Дед - корень\n");
#endif
                dad->p = 0;
                grand->p = dad;
                grand->r = dad->l;
                dad->l->p = grand;
                dad->l = grand;
                this->root = dad;
            }
            else
            {
#ifdef PASTING_BALANCING
                printf("%d 2sb\n", (grand->p->l == grand));
#endif
                if (grand->p->l == grand)
                { //если дед левый сын
#ifdef PASTING_BALANCING
                    printf("Дед - левый сын\n");
#endif
                    grand->p->l = dad;
                    dad->p = grand->p;
                    grand->p = dad;
                    grand->r = dad->l;
                    dad->l->p = grand;
                    dad->l = grand;
                }
                else
                { //если дед правый сын
#ifdef PASTING_BALANCING
                    printf("Дед - правый сын\n");
#endif

                    grand->p->r = dad;
                    dad->p = grand->p;
                    grand->p = dad;
                    grand->r = dad->l;
                    dad->l->p = grand;
                    dad->l = grand;
                }
            }
        } */

        uncle->p->color = 'r';
        dad->color = 'b';
#ifdef SHOW_TREE_IN_BALANCE
        this->ShowTree(this->root);
#endif
    }

    void thirdBalance(Node<T> *n)
    {
#ifdef PASTING_BALANCING
        printf("Это вставка ситуация 3\n");
#endif
        Node<T> *dad = n->p, *grand = dad->p;

#ifdef PASTING_BALANCING
        cout << grand->data << endl;
        cout << dad->data << endl;
        cout << n->data << endl;
#endif

        if ((grand->r == dad) && (dad->l == n))
        {
#ifdef PASTING_BALANCING
            printf("Ставим в линию\n");
#endif
            this->RightRot(n->p, n);
        }
        else
        {
            if ((grand->l == dad) && (dad->r == n))
            {
#ifdef PASTING_BALANCING
                printf("Ставим в линию\n");
#endif

                this->LeftRot(n->p, n);
            }
        }

        if (grand->l != 0)
        {
            this->RightRot(grand, grand->l);
        }
        else
        {
            this->LeftRot(grand, grand->r);
        }
        grand->p->color = 'b';
        grand->color = 'r';
#ifdef PASTING_BALANCING
        this->ShowTree(this->root);
#endif
    }

    Node<T> *OneSide(Node<T> *n, Node<T> *uncle)
    {
        if (((n->p->l == n) && (uncle->p->r == uncle)) || ((n->p->r == n) && (uncle->p->l == uncle)))
        {
#ifdef PASTING_BALANCING
            printf("Расположение удобное\n");
#endif
            return n; //если всё нормально расположено ничего не меняем
        }
        else
        {
#ifdef PASTING_BALANCING
            printf("Меняем расположение\n");
#endif
            Node<T> *dad = n->p, *grand = n->p->p;
            if (n->p->r == n) //если n справа и дядя справа
            {
                this->LeftRot(dad, n);
            }
            else
            { //если n слева и дядя слева
#ifdef PASTING_BALANCING
                printf("n слева и дядя слева\n");
#endif
                this->RightRot(dad, n);
            }
            return dad; //после поворота возвращаем указатель на отца
        }
    }

    Node<T> *FindUncle(Node<T> *n)
    {
        if (n->p->p->r == n->p)
        { //если отец справа
            if (n->p->p->l != 0)
            {
                return n->p->p->l;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            if (n->p->p->r != 0)
            {
                return n->p->p->r;
            }
            else
            {
                return 0;
            }
        }
    }
};

int main()
{
    Node<int> v(1), r(2), t(13), s(4), b(15), a(33), rt(23);
    Tree<int> tr;

    tr.PushTree(r); // 2 1 13 33 4 15
    tr.PushTree(v);
    tr.PushTree(t);
    tr.PushTree(a);
    tr.PushTree(s);



    printf("Pasting has ended.\n");
tr.PrintTree();
  /*   Node<int> *sem = tr.FindNode(0, tr.root);
    tr.PopTree(sem);
    tr.PrintTree();
    sem = tr.FindNode(1, tr.root);
    tr.PopTree(sem);
    tr.PrintTree();
    sem = tr.FindNode(4, tr.root);
    tr.PopTree(sem);
    tr.PrintTree();
    sem = tr.FindNode(2, tr.root);
    tr.PopTree(sem);
    tr.PrintTree(); */
    
/* 
    Node<int> *sem = tr.FindNode(1, tr.root);
tr.PopTree(sem);
    tr.PrintTree(); */


    printf("\ngood bye\n");
}
